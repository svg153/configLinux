# What protocol to use when performing git operations. Supported values: ssh, https
git_protocol: https
# What editor gh should run when creating issues, pull requests, etc. If blank, will refer to environment.
editor: vi
# When to interactively prompt. This is a global config that cannot be overridden by hostname. Supported values: enabled, disabled
prompt: enabled
# A pager program to send command output to, e.g. "less". Set the value to "cat" to disable the pager.
pager:
# Aliases allow you to create nicknames for gh commands
# Examples:
#  * https://gist.github.com/vilmibm/a1b9a405ac0d5153c614c9c646e37d13
#  * https://github.com/vEnhance/dotfiles/blob/main/gh-config.yml
#  * https://github.com/aaronpowell/system-init/blob/master/common/gh-config.yml
#  * https://github.com/cli/cli/issues/1200#issuecomment-659921986
#  * https://campusvirtual.ull.es/ocw/pluginfile.php/19489/mod_resource/content/3/_site/pages/gh.html
aliases:
    aliases: alias list
    wi: |-
        !(
            if [ $# -eq 0 ]; then
                gh wif
            else
                work_item_id=$1
                gh plain-wi ${work_item_id}
            fi
        )
    wif: |-
        !(
            gh wif-simple
        )
    wif-simple: |-
        !(
            gh azdo-get-active-wi-info \
            | fzf --delimiter '\t' \
            | awk '{print $1}' \
            | xargs -I '%' gh plain-new-branch '%'
        )   
    wif-prev: |-
        !(
            gh azdo-get-active-wi-info \
            | fzf --delimiter '\t' \
                --preview "az boards work-item show --id {1} --output json | jq -r '.fields.\"System.Description\"  ' | w3m -dump -T text/html" \
            | awk '{print $1}' \
            | xargs -I '%' gh plain-new-branch '%'
        )
    prs: |-
        !(
            GH_FORCE_TTY='50%' \
            gh pr list \
                | fzf \
                    --ansi --header-lines 3 \
                    --preview 'GH_FORCE_TTY=$FZF_PREVIEW_COLUMNS gh pr view {1}; GH_FORCE_TTY=$FZF_PREVIEW_COLUMNS gh pr checks {1}' \
                | awk '{print $1}'
        )
    open: pr view
    prv: pr view
    sw: |-
        !(
            [ $# -eq 0 ] && git switch main
            [ $# -eq 1 ] && git switch $1
            if [ $# -eq 2 ] && [ $1 = '-c' ] && [ -n $2 ]; then
                git switch -c $2
            fi
        )
    co: |-
        !(
            gh pr checkout \
                $(
                    gh pr list \
                        | fzf \
                        | awk '{print $1}' \
                )
        )
    pro: |-
        !(
            gh co
        )
    prco: |-
        !(
            gh co
        )
    prcr: pr create
    prcrd: |-
        !(
            # Remove next line when https://github.com/cli/cli/issues/1718 is fixed
            git push -u origin HEAD
            gh prcr \
                --fill\
                --draft
        )
    prcrb: |-
        !(
            gh __prcr
        )
    __prcr: |-
        !(
            branch_name=$(gh __branch-name)
            title=$(echo ${branch_name} | tr '-' ' ')
            
            pr_title="${1:-${title}}"
            pr_body="${2:-${title}}"
            
            # TODO: Remove next line when https://github.com/cli/cli/issues/1718 is fixed
            git push -u origin HEAD
            gh prcr --title "${pr_title}" --body "${pr_body}" --draft
        )
    prcrewi: prcrwi
    # TODO: fix
    prcrwi: |-
        !(
            gh plain-prcrwi
        )
    prcrwir: |-
        !(
            gh prcrwi
            gh pr ready
        )
    prci: pr checks
    approve: pr review --approve
    ok: approve
    lgtm: pr review --approve --body "LGTM. Approved from gh cli"
    pr-approve: |-
        !(
            pr_id=""
            [ $# -eq 1 ] && pr_id=$1
            [ -z "${pr_id}" ] && pr_id=$(gh pr list | fzf | awk '{print $1}')
            gh pr-approve-id "${pr_id}"
        )
    pr-approve-last: |-
        !(
            pr_id=$(gh pr list | head -n1 | awk '{print $1}')
            gh pr-approve-id "${pr_id}"
        )
    pr-approve-id: |-
        !(
            if [ $# -ne 1 ]; then
                echo "Usage: gh pr-approve-id [pr_id|branch_name|pr_url]"
                exit 1
            fi
            pr="$1"
            gh pr review \
                ${pr} \
                --approve \
                --body "approved from gh cli"
        )
    merge: |-
        !(
            gh __pr-merge
        )
    codespaces: codespace list
    configs: config list
    renewup: |-
        !(
            folder_name=$(basename $(pwd))
            repo_name=${folder_name}
            
            owner_name=svg153

            is_git_new=false

            if [ $# -eq 1 ]; then
                owner_name=$1
            fi
            if [ $# -gt 1 ]; then
                echo "Usage: gh renewup [owner_name]"
                exit 1
            fi

            if [ ! -d .git ]; then
                git init
                is_git_new=true
            fi

            gh repo create \
                ${repo_name} \
                --private \
                --source=. \
                --remote=upstream

            if [ "${is_git_new}" = true ]; then
                git add .
                git commit -m "first commit"
            fi

            git remote add origin git@github.com:${owner_name}/${repo_name}.git

            git push -u origin main
        )
    clo: repo clone "$1"/"$2"
    repos: repo list
    repos-name-all: |-
        !(
            user=${1:-$USER}
            gh api --paginate graphql -f owner="${user}" -f query='
                query($owner: String!, $per_page: Int = 100, $endCursor: String) {
                    repositoryOwner(login: $owner) {
                        repositories(first: $per_page, after: $endCursor, ownerAffiliations: OWNER) {
                            nodes { name }
                            pageInfo { hasNextPage endCursor }
                        }
                    }
                }
            ' | jq -r '.data.repositoryOwner.repositories.nodes[].name' | sort
        )
    alerts: |-
        !(
            gh repo-dependabot-alerts
        )
    repo-dependabot-alerts: |-
        !(
            user=${1:-$USER}
            repo=${2:-$REPO}
            gh api --paginate graphql -f owner="${user}" -f name="${repo}" -f query='
                query($owner: String!, $name: String!, $per_page: Int = 100, $endCursor: String) {
                    repository(owner: $owner, name: $name) {
                        vulnerabilityAlerts(first: $per_page, after: $endCursor) {
                            nodes {
                                createdAt
                                dismissedAt
                                securityVulnerability {
                                    package {
                                        name
                                    }
                                    advisory {
                                        description
                                    }
                                }
                            }
                            pageInfo { hasNextPage endCursor }
                        }
                    }
                }
            '
        )
    repos-name: |-
        !(
            user=${1:-$USER}
            gh repo list "${user}" --limit 9999 --json "name" --jq ".[].name"
        )
    # https://github.com/matt-bartel/gh-clone-org
    clo-org: clone-org
    clone-repos-all: |-
        !(
            user=${1:-$USER}
            gh repos-name-all "${user}" | xargs -I '%' gh repo clone ${user}/%
        )
    clone-all-repos: |-
        !(
            user=${1:-$USER}
            gh clone-repos-all ${user}
        )
    issues: issue list
    releases: release list
    runs: run list
    runs-branch: |-
        !(
            gh run list --branch=$(git branch --show)
        )
    execute-workflow-branch: |-
        !(
            if [ $# -lt 1 ]; then
                echo "Usage: gh execute-workflow-branch <workflow_filerelpath> [workflow_args]"
                exit 1
            fi
            workflow_filepath="$(git rev-parse --show-toplevel)/$1"; shift
            if [ -z "${workflow_filepath}" ]; then
                echo "<workflow_filerelpath> is required"
                exit 1
            fi
            workflow_args="$@"
            workflow_name_to_run=$(yq '.name' ${workflow_filepath})
            branch_name=$(gh __branch-name)
            gh workflow run "${workflow_name_to_run}" --ref "${branch_name}" ${workflow_args}
        )
    secrets: secret list
    ssh-keys: ssh-key list
    workflows: workflow list
    list-milestones: |-
        api graphql -F owner=':owner' -F name=':repo' -f query='
            query ListMilestones($name: String!, $owner: String!) {
                repository(owner: $owner, name: $name) {
                    milestones(first: 100) {
                        nodes {
                            title
                            number
                            description
                            dueOn
                            url
                            state
                            closed
                            closedAt
                            updatedAt
                        }
                    }
                }
            }
        '
    lm: |-
        !(
            gh list-milestones | jq '.data.repository.milestones.nodes[]'
        )
    rate-limit: |-
        !(
            gh api \
                -H "Accept: application/vnd.github.v3+json" \
                /rate_limit
        )
    rate-limit-table: |-
        !(
            gh api \
                -H "Accept: application/vnd.github.v3+json" \
                /rate_limit \
            | jq '.resources' \
            | jq -r '(["LIMIT","USED","REMAINING","RESET"] | (., map(length*"-"))), (.[] | [.limit, .used, .remaining, .reset]) | @tsv'
        )
    ####
    # Tools
    ####
    new-branch-azdo: |-
        !(
            wi_id="$1"
            wi_title="$2"
            
            git sw -c "AB-${wi_id}_${wi_title}"
        )
    new-branch-from-azdo-wi: |-
        !(
            wi_id="$1"
            wi_title="$(gh azdo-item-title "${wi_id}")"
            
            gh new-branch-azdo "${wi_id}" "${wi_title}"
        )
    # TODO: remove this, duplicated into bash_aliases, use bash commands intead of run gh commands for all. Create branches better from bash aliases and with the branch name, take the info for the next commands.
    azdo-item-title: |-
        !(
            wi_id="$1"
            az boards work-item show \
                --id "${wi_id}" \
                --output json \
                --query 'fields."System.Title"' \
                | tr '[:upper:]' '[:lower:]' \
                | tr -d '!"#$%&'"'"'()*+,./:;<=>?@[\\]^_`{|}~-' \
                | sed -e 's/[ \t]*$//' \
                | tr ' ' '-'
        )
    azdo-get-active-wi-ids: |-
        !(
            az boards query  \
                --wiql "SELECT [System.Id] FROM workitems WHERE [System.WorkItemType] = 'User Story' AND ([System.State] = 'ToDo' OR [System.State] = 'Active')" \
                --query "[*].id" \
                --output tsv
        )
    azdo-get-active-wi-info: |-
        !(
            gh azdo-get-active-wi-ids \
            | xargs --max-procs 8 -I '%' sh -c \
                "az boards work-item show --id '%' --output json | jq -r '.fields | {id: .\"System.Id\"  , title: .\"System.Title\"  , state: .\"System.State\"  , assigned: .\"System.AssignedTo.displayName\"   } | [.id, .title, .state, .assigned] | @tsv'"
        )
    ####
    # Company
    ####
    # plain
    plain-wi: |-
        !(
            wi_id="$1"
            gh plain-new-branch ${wi_id}
        )
    plain-new-branch: |-
        !(
            wi_id="$1"
            gh new-branch-from-azdo-wi ${wi_id}
        )
    plain-prcrwi: |-
        !(
            branch_name=$(gh __branch-name)
    
            ab_id=$(echo ${branch_name} | awk -F'_' '{print $1}')
            wi_id=${ab_id}
            if [[ ${ab_id} == "AB-"* ]]; then
                azdo_wi=$(echo ${wi_id} | sed 's/AB-//')
            else
                azdo_wi=${wi_id}
            fi
            wi_title=$(echo ${branch_name} | awk -F'_' '{print $2}')
            
            pr_title="${azdo_wi} ${wi_title}"
            pr_body='#'"${azdo_wi}"
            
            # get the default branch of the repository from az devops
            repository_name=$(git remote get-url origin | awk -F'/' '{print $3}')
            repository_name_decoded=$(echo ${repository_name} | sed 's/%20/ /g' | sed 's/%2F/\//g')
            default_branch=$(az repos show --repository "${repository_name_decoded}" --query "defaultBranch" -o tsv)
            default_branch=$(echo ${default_branch} | sed 's/refs\/heads\///')
            
            git push -u origin HEAD
            
            az repos pr create \
                --title "${pr_title}" \
                --description "${pr_body}" \
                --source-branch "${branch_name}" \
                --target-branch "${default_branch}" \
                --work-items "${azdo_wi}"
        )
    # pezaio
    pezaio-wi: |-
        !(
            wi_id="$1"
            gh pezaio-new-branch ${wi_id}
        )
    pezaio-new-branch: |-
        !(
            wi_id="$1"
            gh new-branch-from-azdo-wi ${wi_id}
        )
    pezaio-wif: |-
        !(
            project=PaymentPlatform
            IterationPath="${project}\Sprint $(date +%Y-%V)"
            azdo_web="https://dev.azure.com/pezaio"
            az boards query --org ${azdo_web} --project ${project} \
                --wiql "SELECT [System.Id] FROM workitems WHERE [System.WorkItemType] = 'User Story' AND ([System.State] = 'ToDo' OR [System.State] = 'Active') AND [System.IterationPath] = \"${IterationPath}\""  \
                --query "[*].{id:id,url:url}" \
                --output json \
            | jq -r '.[].id' \
            | fzf --preview 'az boards work-item show --id {1} --org https://dev.azure.com/pezaio --output table'
        )
    pezaio-prcrwi: |-
        !(
            root_dir=$(git rev-parse --show-toplevel)
            branch_name=$(gh __branch-name)
            wi_id=$(echo ${branch_name} | awk -F'_' '{print $1}')
            wi_title=$(echo ${branch_name} | awk -F'_' '{print $2}')

            wi_id_azdo=$(echo ${wi_id} | tr '-' '#')
            wi_id_azdo_num=$(echo ${wi_id_azdo} | awk -F'#' '{print $2}')
            wi_title_azdo=$(echo ${wi_title} | tr '-' ' ')

            pr_title="${wi_id_azdo} ${wi_title_azdo}"

            # if there is pull_request_template.md file in the .github folder, use it as pr body
            # pr_tmpl=${root_dir}/.github/pull_request_template.md
            # Force not enter
            pr_tmpl=${root_dir}/.github/pull_request_template.md
            pr_body_temp_file=$(mktemp -t pr_body_XXXXX.md)
            chmod 666 ${pr_body_temp_file}
            #trap "rm -f ${pr_body_temp_file}\" EXIT

            if [ -f "${pr_tmpl}" ]; then
                # Modify the template using sed
                modified_template=$(cat "${pr_tmpl}")
                modified_template=$(echo "${modified_template}" | sed '/<!--/,/-->/d')
                modified_template=$(echo "${modified_template}" | sed "s@### User Stories/Bugs affected@### User Stories/Bugs affected\\n\\nRelated ${wi_id_azdo}@")
                modified_template=$(echo "${modified_template}" | sed 's@### Other systems impacted@### Other systems impacted\\n\\n- N/A@')
                modified_template=$(echo "${modified_template}" | sed 's@- \\[ \\] No@- [x] No@')
                # Remplace double empty lines with one empty line
                modified_template=$(echo "${modified_template}" | sed ':L;N;s/^\\\\n$//;t L')
                echo "${modified_template}" > ${pr_body_temp_file}
                
                pr_body="${pr_body_temp_file}"
            else
                pr_body="${wi_id_azdo}"
            fi

            # TODO: Remove next line when https://github.com/cli/cli/issues/1718 is fixed
            git push -u origin HEAD

            bash -c "gh prcr \
                --title \"${pr_title}\" \
                --body-file \"${pr_body}\" \
                --draft"
        )
    pezaio-dependabot-merge: |-
        !(
            git stash
            gh approve
            gh pr merge \
                --auto \
                --squash \
                --delete-branch
            git stash pop
        )
    ####
    # typos
    ####
    lsit: list
    ####
    # private
    ####
    __branch-name: |-
        !(
            git rev-parse --abbrev-ref HEAD
        )
    __pr-merge: |-
        !(
            branch_name=$(gh __branch-name)
            gh pr merge \
                ${branch_name} \
                --auto \
                --squash \
                --delete-branch
        )
# The path to a unix socket through which send HTTP connections. If blank, HTTP traffic will be handled by net/http.DefaultTransport.
http_unix_socket:
# What web browser gh should use when opening URLs. If blank, will refer to environment.
browser:
version: "1"
